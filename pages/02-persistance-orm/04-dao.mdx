import {Callout} from 'nextra/components'
import {Details} from '../../components/details'

### Wprowadzenie
Tym razem kod zajmujący się operacjami na bazie umieścimy nie w klasach modelu (`Student`, `Course`, `Grade`), a w specjalnie stworzonych do tego tzw. DAO - Data Access Object.
Każdej klasie domenowej będzie odpowiadało obsługujące ją DAO.

### GenericDao

Klasa `GenericDao` jest bazą do budowania kolejnych DAO. Posiada ona metody:

* `public void save(T object)` - metoda zapisująca obiekt do bazy.
* `public void update(T object)` - metoda aktualizująca stan obiektu w bazie.
* `public Session currentSession()` - metoda pozwalająca na stworzenie obiektu `Session`, który będziemy wykorzystywać następnie do tworzenia zapytań do bazy danych.

Wszystkie DAO (`StudentDao`, `GradeDao`, `CourseDao`) rozszerzają klasę `GenericDao`.

### StudentDao

1. Zaimplementuj metodę `create()` w klasie `StudentDao`. Skorzystaj z metody `save()`. Pamiętaj o złapaniu wyjątku `PersistenceException` rzucanego przez metodę `GenericDao.save()`.  
Sprawdź poprawność wykonania tego zadania uruchamiając test `createStudentTest()`.

1. Zaimplementuj metodę `findByIndexNumber()` w klasie `StudentDao`. Użyj do tego metody `currentSession().createQuery()`. Pamiętaj o złapaniu wyjątku `PersistenceException`.  
Sprawdź poprawność wykonania tego zadania uruchamiając test `findStudentIndexTest()`.


<Callout type="info">

**Pytanie:**
Czy w momencie ładowania obiektu klasy `Student` ładujemy do pamięci zbiór wszystkich ocen i kursów powiązanych z danym studentem? Spróbuj odpowiedzieć w ciągu 60 sekund, jeśli Ci się nie uda - otwórz wniosek.

Daj sobie 60 sekund na odpowiedź. :) 
</Callout>

<br />

<Details>
To, że nie mogłeś odpowiedzieć na to pytanie w ciągu 60 sekund pokazuje nam pewną istotną kwestię związaną ze wzorcem Object-Relational Mapping. 
Delegując ładowanie elementów z bazy do biblioteki oddajemy jej część odpowiedzialności. Oczywiście możemy dowolnie konfigurować sposób ładowania danych, natomiast wymaga to głębszej znajomości biblioteki i na pierwszy rzut oka jest mniej oczywiste niż w Active Record.
Jeśli popełnimy błąd przy konfiguracji to może się okazać, że wczytujemy **całą** naszą bazę danych przy pojedynczym zapytaniu, co w oczywisty sposób zabija wydajność aplikacji.
</Details>


### Zapisywanie studenta na dany kurs
Zaimplementuj metodę `enrollStudent()` w klasie `CourseDao`. Tym razem zamiast ręcznie tworzyć rekord w bazie danych musimy:

1. Dodać studenta do zbioru studentów w klasie `Course`.
1. Dodać kurs do zbioru kursów w klasie `Student`.
1. Zaktualizować stan obiektu zapisany w bazie. Służy do tego metoda `update()`, dziedziczona z `GenericDao`.

Pamiętaj, że metoda `enrollStudent()` powinna zwracać `false`, jeśli student jest już zapisany na dany kurs!.

Sprawdź poprawność wykonania tego zadania uruchamiając test `enrollStudentTest()`.


### Ocenianie studenta
Zaimplementuj metodę `gradeStudent()` w klasie `GradeDao`. Pamiętaj, że musisz:

1. Utworzyć obiekt `Grade`.
1. Dodać ocenę do zbioru ocen w klasie `Student`
1. Dodać ocenę do zbioru ocen w klasie `Course`
1. Zaktualizować stan obiektu zapisany w bazie.

Sprawdź poprawność wykonania tego zadania uruchamiając test `gradeStudentTest()`.


### Pobieranie listy studentów

<Callout type="info">
W poprzednim ćwiczeniu (Active Record) implementowaliśmy też metodę pozwalającą na pobieranie listy studentów zapisanych na dany kurs. Czy teraz też musimy to robić?
</Callout>

<br />

<Details>
Nie. Tym razem w klasie Course posiadamy pole ze zbiorem studentów. Za jego ładowanie odpowiedzialny jest Hibernate.
</Details>

<Callout type="info">
Jeśli chcesz zobaczyć, jakie dokładnie zapytania SQL wykonuje Hibernate w trakcie działania programu, w pliku `src/test/resources/hibernate.cfg.xml` dodaj wpis:
```
<property name="hibernate.show_sql">true</property>
```
</Callout>
