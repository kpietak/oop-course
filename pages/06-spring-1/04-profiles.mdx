import {Callout} from 'nextra/components'
import {Details} from '../../components/details'

# Profile Spring

Do tej pory korzystaliśmy z jednej, ustalonej konfiguracji beanów. W praktyce będziemy często uzależniali działanie fragmentów systemu od konkretnego zastosowania, tzw. **profilu aplikacji**. Przykładowo aplikacja w wersji deweloperskiej będzie uruchamiać bazę danych lokalnie, w wersji do testów podmieni bazę na testy w pamięci, a wersji produkcyjnej skomunikuje się z zewnętrzną bazą.

Używając mechanizmu profili Spring możemy w łatwy sposób zmieniać zachowanie wybranych fragmentów systemu, podmieniając określone właściwości lub całe klasy. Często będziemy wykorzystywać tutaj poliforfizm i zasadę odwrócenia zależności, podobnie jak na poprzednich zajęciach.

### Wstrzykiwanie właściwości systemu

1. Znajdź plik `application.properties` w zasobach projektu (`src/main/resources`). Znajdują się tu wszystkie właściwości systemu w formacie `klucz=wartość`. Można odwoływać się do nich potem w projekcie lub zmieniać wartości, używane przez biblioteki (również samego Springa).
2. Dodaj nową właściwość, reprezentującą wersję aplikacji, np. `school.app.version` i nadaj jej dowolną wartość.
3. Właściwości mogą być wstrzykiwane podobnie jak inne beany. Trzeba jedynie oznaczyć je adnotacją `@Value`. W klasie `SchoolInitializer` wstrzyknij przygotowaną wcześniej właściwość. Format wstrzykiwanego parametru powinien być następujący: `@Value("{nazwa.właściwości}) String parameter`.
4. Zapewnij, by aplikacja wypisywała swoją wersję po zainicjowaniu `SchoolInitializer` i przetestuj, czy działa.  

### Podmiana właściwości systemu w zależności od profilu

1. Dodaj nowy plik `application-dev.properties` w zasobach systemu. Będzie on reprezentował właściwości, które mają być dostępne jedynie wówczas, gdy aplikacja działa w profilu `dev`. 
    
    <Callout type="info">
    Nazwy profili mogą być dowolne, typowo będzie to: `dev`, `prod` oraz `test`.  
    </Callout>
1. W stworzonym pliku ponownie zdefiniuj właściwość określającą wersję aplikacji, ale nadaj jej inną wartość (klucz powinien być taki sam!). Np. zamiast wersji `1.0` możesz zdefiniować `1.0-dev`.
2. Zmodyfikuj konfigurację aplikacji tak, by uruchamiała się w profilu `dev`.   
    <Details>
        1. Jeśli posiadasz plugin do IntelliJ obsługujący Springa (np. masz zainstalowane IntelliJ Ultimate) to wystarczy dodać nazwę profilu w konfiguracji uruchomieniowej (`Edit configurations...`):  
        ![Konfiguracja z pluginem](/06-spring1/profiles1.png)
        2. W przeciwnym przypadku uruchom program z argumentem VM: `-Dspring.profiles.active=dev`.  
        ![Konfiguracja profili z flagą](/06-spring1/profiles2.png)  
    </Details>
3. Zweryfikuj, czy na konsoli wypisuje się prawidłowa wartość wersji aplikacji.

### Podmiana klas w zależności od profilu

W tej części zadania dodamy nowy rodzaj serwisu do notyfikacji, który docelowo będzie wysyłał maile do studentów, którzy otrzymali oceny. Użyjemy tutaj **Spring Mail** oraz biblioteki **GreenMail**, która symuluje wysyłanie maili (nie będzie konieczności wysyłania prawdziwych wiadomości!).

1. w konfiguracji `build.gradle` dodaj brakujące biblioteki i odśwież projekt:  
    ```  
    implementation 'org.springframework.boot:spring-boot-starter-mail'  
    implementation 'com.icegreen:greenmail:2.1.6'
    ```
2. Stwórz nowy serwis w pakiecie `pl.edu.agh.to.school.notification`: `EmailNotificationService`. Powinien on implementować `NotificationService`.
3. Wstrzyknij przez konstruktor instancję `JavaMailSender` - będzie to uniwersalny interfejs do wysyłania wiadomości. 
4. Zaimplementuj metodę `notify` tak, by wykorzystywała przygotowane narzędzie. Możesz skorzystać z poniższego kodu:  
    ```java
    SimpleMailMessage msg = new SimpleMailMessage();
    msg.setFrom("nauczyciel@agh.edu.pl");
    msg.setTo(student.getEmail());
    msg.setSubject("New grade: " + grade.course().getName());
    msg.setText("You received a new grade: " + grade.value());
    mailSender.send(msg);
    ```
5. Dodaj nowe bean factory `GreenMailConfig`, które stworzy beana `GreenMail`. `GreenMail` w konstruktorze wymaga podania obiektu konfiguracji serwera, który można stworzyć w następujący sposób:  
    ```java  
    ServerSetup smtp = new ServerSetup(1025, "localhost", ServerSetup.PROTOCOL_SMTP);
    ```
    <Callout>
    Zwróć uwagę, że w ten sposób możemy łatwo dostarczać beany, które pochodzą z zewnętrznych bibliotek i nie są kompatybilne ze Springiem. `GreenMail` nie jest serwisem/komponentem Springa, a mimo to możemy go skonfigurować i stworzyć tak, by dało się go wstrzykiwać.  
    </Callout>
6. Dodaj jeszcze jedną klasę w tym samym pakiecie: `GreenMailHandler`. Wstrzyknij do niej `GreenMail`. Dodaj metodę, która powinna wywołać się podczas zamykania systemu i wypisywać zgromadzone maile, wysłane podczas sesji:
    ```java
    @PreDestroy
    private void showAllGatheredEmails() throws MessagingException {
        for (MimeMessage message : greenMail.getReceivedMessages()) {
            String formattedMessage = "From: " + Arrays.toString(message.getFrom()) +
                    " | Subject: " + message.getSubject() +
                    " | Body: " + GreenMailUtil.getBody(message);
            System.out.println(formattedMessage);
        }
        greenMail.stop();
    }
